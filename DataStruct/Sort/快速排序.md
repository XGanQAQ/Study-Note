**快速排序**（Quick Sort）是基于分治法（Divide and Conquer）的一种高效排序算法。它通过递归地将数组分为两部分，每次选择一个**基准（Pivot）**元素，将小于基准的元素放在左侧，大于基准的元素放在右侧，从而达到排序的目的。

通过选择基准把数组分为两部分，然后递归地对左右子数组进行排序，直到整个数组有序。  
快速排序是一种不稳定的排序算法，最坏情况下的时间复杂度为 O(n²)，平均情况下的时间复杂度为 O(n log n)。

---

### **算法思想**
1. **分区（Partition）**：
   - 从数组中选择一个基准元素（Pivot）。
   - 遍历数组，将小于基准的元素移动到左侧，大于基准的元素移动到右侧。
   - 基准元素归位（放在正确的排序位置）。
   
2. **递归排序**：
   - 对基准左侧和右侧的子数组分别递归执行快速排序。
   - 递归的基准条件是子数组的大小为 1 或 0（无需排序）。

---

### **时间复杂度**
- **最好情况**：O(n log n)（每次分区时都恰好平衡地分成两部分）。
- **平均情况**：O(n log n)（基准随机化的情况下）。
- **最坏情况**：O(n²)（每次分区时极不平衡，比如总是选择最小或最大元素作为基准）。
- **空间复杂度**：O(log n)（递归栈深度）。
- **稳定性**：不稳定（同值元素可能因交换顺序改变）。

---

### **算法步骤**
1. 选择一个基准元素（通常是数组的第一个、最后一个或中间元素）。
2. 对数组进行分区，使得：
   - 左侧元素 ≤ 基准元素。
   - 右侧元素 ≥ 基准元素。
3. 递归地对左右子数组进行快速排序。

---

### **C++ 实现**
以下是一个简单的快速排序实现：

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 分区函数，返回基准元素的最终位置
int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high]; // 基准元素选为最后一个
    int i = low - 1;       // i 指向小于基准的区域尾部

    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++; // 扩大小于基准的区域
            swap(arr[i], arr[j]);
        }
    }
    // 将基准元素放置到正确位置
    swap(arr[i + 1], arr[high]);
    return i + 1;
}

// 快速排序函数
void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pivotIndex = partition(arr, low, high); // 分区，获取基准索引
        quickSort(arr, low, pivotIndex - 1);        // 排序左子数组
        quickSort(arr, pivotIndex + 1, high);      // 排序右子数组
    }
}

int main() {
    vector<int> data = {10, 7, 8, 9, 1, 5};
    cout << "排序前：";
    for (int num : data) {
        cout << num << " ";
    }
    cout << endl;

    quickSort(data, 0, data.size() - 1);

    cout << "排序后：";
    for (int num : data) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
```

---

### **执行过程**
以数组 `{10, 7, 8, 9, 1, 5}` 为例：

1. 初始数组：`{10, 7, 8, 9, 1, 5}`，基准元素为 5：
   - 分区后：`{1, 5, 8, 9, 10, 7}`，基准元素位置为 1。

2. 对左侧 `{1}` 和右侧 `{8, 9, 10, 7}` 递归排序：
   - 对右侧，基准为 7：
     - 分区后：`{1, 5, 7, 9, 10, 8}`，基准位置为 2。

3. 重复上述步骤，直到整个数组有序：
   - 最终结果：`{1, 5, 7, 8, 9, 10}`。

---

### **优缺点**
#### **优点**：
- 平均时间复杂度低，适合处理大规模数据。
- 使用分治思想，递归结构简洁优雅。

#### **缺点**：
- 最坏情况下效率低（O(n²)），需优化基准选择。
- 不稳定排序，可能打乱相等元素的顺序。

---

### **优化方法**
1. **随机化基准选择**：随机选择基准元素，避免最坏情况。
2. **三数取中法**：选择首、尾、中三个元素的中间值作为基准。
3. **尾递归优化**：减少递归栈的使用。

如果还有其他排序算法需要了解，可以继续告诉我！