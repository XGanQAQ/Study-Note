**选择排序**（Selection Sort）是一种简单直观的排序算法。它通过多次选择未排序部分中的最小（或最大）元素，依次放到已排序部分的末尾，从而逐步将数组变为有序。

---

### **算法思想**
1. 每次从未排序部分中找到最小（或最大）元素。
2. 将这个元素与未排序部分的第一个元素交换位置。
3. 重复上述过程，直到数组完全有序。

---

### **算法步骤**
1. 从第一个位置开始，扫描整个数组找到最小元素。
2. 将最小元素与当前位置的元素交换。
3. 对剩余未排序部分重复上述操作。
4. 直到只剩下一个元素为止。

---

### **时间复杂度**
- **最坏情况**：O(n²)  
- **最好情况**：O(n²)  
- **平均情况**：O(n²)  
（无论数组是否有序，时间复杂度都一样，因为每次都需要扫描剩余元素）  
- **空间复杂度**：O(1)（原地排序）  
- **稳定性**：不稳定（当最小元素与前面的元素交换时，可能破坏相对顺序）。

---

### **适用场景**
- 简单实现场景。
- 小规模数据场景（效率低，不适合大数据量）。

---

### **C++ 实现**
以下是选择排序的简单实现：

```cpp
#include <iostream>
#include <vector>
using namespace std;

void selectionSort(vector<int>& arr) {
    int n = arr.size();

    for (int i = 0; i < n - 1; i++) {
        int minIndex = i; // 假设当前索引为最小值

        // 寻找未排序部分的最小值
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }

        // 如果找到更小值，则交换
        if (minIndex != i) {
            swap(arr[i], arr[minIndex]);
        }
    }
}

int main() {
    vector<int> data = {64, 34, 25, 12, 22, 11, 90};
    cout << "排序前：";
    for (int num : data) {
        cout << num << " ";
    }
    cout << endl;

    selectionSort(data);

    cout << "排序后：";
    for (int num : data) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
```

---

### **执行过程**
以数组 `{64, 34, 25, 12, 22, 11, 90}` 为例：

1. 初始数组：`{64, 34, 25, 12, 22, 11, 90}`  
   - 最小值为 11，与第一个元素交换。  
   - 结果：`{11, 34, 25, 12, 22, 64, 90}`。

2. 第二轮：在剩余部分 `{34, 25, 12, 22, 64, 90}` 中找到最小值 12，与 34 交换。  
   - 结果：`{11, 12, 25, 34, 22, 64, 90}`。

3. 第三轮：在剩余部分 `{25, 34, 22, 64, 90}` 中找到最小值 22，与 25 交换。  
   - 结果：`{11, 12, 22, 34, 25, 64, 90}`。

4. 重复以上过程，直到排序完成：  
   - 最终结果：`{11, 12, 22, 25, 34, 64, 90}`。

---

### **优缺点**
#### **优点**：
- 简单直观，易于实现。
- 不依赖输入数据的初始顺序。

#### **缺点**：
- 效率较低，不适合大数据量。
- 不稳定排序，可能打乱相等元素的顺序。

如果还有疑问或者需要比较其他排序算法，欢迎随时提问！