树的存储结构主要有两种：**顺序存储结构**和**链式存储结构**。根据树的特点和应用场景，这两种存储结构可以适用于不同类型的树形数据。

### 1. 顺序存储结构
顺序存储结构通常使用数组来存储树的节点，比较适合完全二叉树或满二叉树。

- **完全二叉树的顺序存储**：对于一个完全二叉树，其节点可以按层次编号（从根节点开始，层次由上至下，左右由左到右），编号为 `i` 的节点存储在数组的第 `i` 个位置（从1开始编号）。
    - 若节点 `i` 的编号是 `i`，则：
      - 其左孩子的编号为 `2*i`
      - 其右孩子的编号为 `2*i + 1`
      - 其父节点编号为 `i / 2`
      
- **优点**：
  - 适用于完全二叉树，能高效利用数组的空间。
  - 不需要存储额外的指针，节省存储空间。
  
- **缺点**：
  - 对于一般的树或非完全二叉树，会浪费很多存储空间，因为数组中的很多位置可能没有节点。
  - 数组大小固定，难以动态扩展。

### 2. 链式存储结构
链式存储结构是用链表的形式来存储树的节点，每个节点包含数据和指针。根据树的类型和实际需求，可以选择不同的链式结构。

#### 1. 二叉链表
二叉链表适用于二叉树，每个节点包含数据域和两个指针域，分别指向左右孩子。

```c
struct TreeNode {
    int data;
    TreeNode *left;   // 左孩子指针
    TreeNode *right;  // 右孩子指针
};
```

- **优点**：
  - 动态存储结构，不会浪费空间。
  - 插入和删除节点相对方便，适合需要频繁修改树结构的情况。
  
- **缺点**：
  - 需要额外的指针空间，对于非常大的树会带来一定的空间开销。

#### 2. 三叉链表
三叉链表在二叉链表的基础上增加一个指向父节点的指针，方便节点向上回溯。每个节点包含三个指针域：左孩子、右孩子和父节点。

```c
struct TreeNode {
    int data;
    TreeNode *left;   // 左孩子指针
    TreeNode *right;  // 右孩子指针
    TreeNode *parent; // 父节点指针
};
```

- **优点**：
  - 便于查找父节点，适合需要频繁回溯的情况。
  
- **缺点**：
  - 增加了额外的指针空间开销。

#### 3. 孩子链表（孩子表示法）
适合存储多叉树或一般树。对于每个节点，维护一个链表存储其所有孩子。

```c
struct TreeNode {
    int data;
    ChildNode *firstChild; // 第一个孩子指针
};

struct ChildNode {
    TreeNode *child;       // 孩子节点指针
    ChildNode *nextSibling; // 下一个兄弟节点指针
};
```

- **优点**：
  - 适合任意多叉树的表示，不局限于二叉树。
  - 可以节省空间，且便于动态扩展。
  
- **缺点**：
  - 查找父节点较困难，适合以孩子为主的遍历操作。

#### 4. 孩子兄弟表示法
在多叉树中，将每个节点的第一个孩子和下一个兄弟用指针连接，这样可以用类似二叉树的结构表示多叉树。

```c
struct TreeNode {
    int data;
    TreeNode *firstChild;   // 第一个孩子指针
    TreeNode *nextSibling;  // 下一个兄弟指针
};
```

- **优点**：
  - 统一了树和二叉树的表示，便于使用二叉树的算法来处理多叉树。
  
- **缺点**：
  - 对于查找任意孩子节点的效率较低。

### 存储结构选择总结
- **完全二叉树**：优先使用顺序存储结构。
- **二叉树**：优先使用二叉链表或三叉链表。
- **一般树/多叉树**：适合使用孩子链表或孩子兄弟表示法。