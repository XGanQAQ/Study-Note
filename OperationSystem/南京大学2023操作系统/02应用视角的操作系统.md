# 应用视角的操作系统

## Hello OS World 最小的程序
在操作系统中，最小的程序是什么样的？如何构建最小的程序？
通过汇编语言进行编程，构造最小程序。

程序的指令集里面并没有退出/关闭指令？是谁让程序停下来的？
是系统调用，程序通过系统调用退出
## 一切都是状态机
为什么说一切程序就是状态机？
程序的本质是状态的变化。在程序运行过程中，状态会发生变化。
程序由内存和寄存器组成，状态、普通指令、systemcall。

怎样理解数学定义上的状态机？比如常见的状态转移方程到底是什么？这属于数学的什么学科范围的知识？
数据上定义的状态机有多个关键要素，如
- 状态集合States
- 输入集合Inputs
- 转移函数Transition function
- 初始状态Initial States
- 终止状态Finial States

## 操作系统上的应用程序
操作系统就像一个生态，有最基本的工具，还有各种各样的应用程序。  
但是它们本质都是像上述一样的状态机/最小应用程序。  
利用工具来分析程序，屏蔽掉你不想看到的，观察你需要的。
通过跟踪程序如何和操作系统的交互来学习，并可以把产生的日志文件保存下来，筛选查看学习。

图形界面程序实际上是通过系统调用来实现的，通过系统调用来实现图形界面的显示。程序负责发送数据给操作系统，操作系统负责显示。

## C解释器
C语言生成的二进制文件里面并不包括系统调用Syscall，那么Syscall是怎么来的？
操作系统是C语言编写的，那么C语言可以脱离操作系统运行吗？什么时候可以？为什么可以？什么时候不可以？为什么不可以？
C语言可以直接编写操作硬件的代码，经过编译汇编链接变为机器码在机器上运行。

状态机的本质是什么？什么是初始状态、状态转移？如何正确的理解状态机？状态机与编译器的关系？
编译器把高级语言的状态机编译成底层语言的状态机。作为状态机的翻译器

## 重新理解编译器，编译器原理，编译器优化

## 作业
### Minimal Progame
通过汇编语言编写最小的程序
编写一个汇编文件 .asm
先用汇编器把 .asm 汇编成 .o 二进制文件
再用链接器 把.o 转换为可执行的文件
```bash
as minimal.asm # 汇编
ld minimal.asm -o minimal #链接
```

//TODO: 待解决汉诺塔问题
### 汉诺塔

## 课程提到的便捷指令

```bash
file filePath # 查看文件类型，猜测文件类型
objdump -d filePath # 查看文件的汇编代码
wc -l filePath # 查看文件的行数
gcc -static -o hello hello.c # 编译静态链接的可执行文件
gcc -static -verbose -o hello hello.c # 查看编译过程
gcc -Wl # 链接器参数
ld #链接
gdb #debug?
man 2 syscall #操作系统调用文档
strace #跟踪系统调用
```