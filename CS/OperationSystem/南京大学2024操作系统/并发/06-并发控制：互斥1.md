# 并发控制：互斥
原子的 load() 和 store()

## 互斥问题
用一个锁来保护共享资源，使得在任意时刻只有一个线程可以访问共享资源，这种技术称为互斥。

局部性原理：程序在执行时，只会访问一小部分数据，而不是所有数据。因此，只需要保护那些可能被多个线程同时访问的数据，而不是所有数据。

## 关中断实现单处理器互斥
并发
中断导致

通过对中断的讨论，来讨论在一个cpu上互斥的实现。

在单处理器状态下，通过关闭中断，让处理器不会在各个程序的运行切换，这样子就可以保证互斥

## Peterson算法 共享内存上实现互斥
解决两个进程互斥问题的经典方法，适合理解并发控制的基本原理

实现正确的Peterson算法的条件？为什么需要这个条件？Perterson算法需要在什么情况下进行？

## 多处理器系统上的互斥

软件不管，硬件来凑
- 原子指令

自旋锁

无锁并发算法