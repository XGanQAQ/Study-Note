阴影的生成原理看似简单，但是具体执行过程，需要多处协调配合，需要思考理解。
## 阴影的重要性
没有办法分辨出环面距离它下方纹理立方体的距离。
大脑需要通过阴影，才能针对我们所看到的物体以及他们的位置关系构建完整的“心理模型”

## 投影阴影
一种很适合在地平面上绘制阴影，又相对不需要付出太大计算代价的方法，叫作投影阴影（projective shadows）。
给定一个位于(xL, yL, zL)的点光源、一个需要渲染的物体，以及一个投射阴影的平面，可以通过生成一个变换矩阵，将物体上的点(xW, yW, zW)变换为相应阴影在平面上的点(xS, 0, zS)。之后将其生成的“阴影多边形”绘制出来，通常使用暗色物体与地平面纹理混合作为其纹理。
投影阴影的优点是高效和易于实现。但是，它仅适用于平坦表面。

## 阴影体
找到被物体阴影覆盖的阴影体，之后减少视体与阴影体相交部分中的多边形的颜色强度。
计算成本也很高

## 阴影贴图（重点！！！）
阴影贴图是用于投射阴影的实用且流行的方法，虽然并不总是像阴影体一样准确（且通常伴随着讨厌的伪影），但实现起来更简单，可以在各种情况下使用，并享有强大的硬件支持。

计算阴影的策略是，暂时将相机移动到光的位置，应用 Z-buffer算法，然后使用生成的深度信息来计算。

- 从光源的位置渲染场景。对于每个像素，深度缓冲区包含光源与最近的对象之间的距离。
- 将深度缓冲区复制到单独的“阴影缓冲区”。
- 正常渲染场景。对于每个像素，在阴影缓冲区中查找相应的位置。如果相机到渲染点的距离大于从阴影缓冲区检索到的值，则在该像素处绘制的对象离光源的距离比当前离光源最近的对象离光源更远，因此该像素处于阴影中。

上述方法通常称为“阴影缓冲区”。而将深度缓冲区复制到纹理中的过程称为“阴影贴图”
当纹理对象用于储存阴影深度信息时，我们称其为阴影纹理。

### 阴影贴图（第一轮） 从光源位置绘制物体
相机从光源位置渲染场景，得到深度信息
#### 需要处理的细节
- 配置缓冲区和阴影纹理
- 禁用颜色输出
- 在光源处构建一个LookAt矩阵
- 构造ShadowMVP矩阵
	- 这是以光源为观察点的MVP矩阵
	- V为LookAt矩阵
- 为每个对象创建shadowMVP矩阵并调用绘制。

### 阴影贴图（中间步骤）将深度缓冲区复制到纹理
目标：**将深度缓冲区深度数据放入纹理单元**

- 第一种方法是生成空阴影纹理，然后使用命令 glCopyTexImage2D()将活动的深度缓冲区复制到阴影纹理中

- 第二种方法是在第 1 轮中构建一个“自定义帧缓冲区”（而不是使用默认的深度缓冲区），并使用命令 glFrameBufferTexture()将阴影纹理附加到它上面。**以下实现采用此方法**

### 阴影贴图（第 2 轮）渲染带阴影的场景

从纹理贴图查找像素需要构建一个额外的变换矩阵，通常称为 B，将用于从相机空间到纹理空间的转换。
矩阵B，从OpenGL 相机使用的[−1,+1]坐标空间，到纹理贴图使用的[0,1]空间
B 代表的变换过程很简单——先缩放为 1/2，再平移 1/2。
#### 需要处理的细节
- 构造变换矩阵B，用于从光照空间转换到纹理空间
- 启用阴影纹理
- 启用颜色输出
- 启用第二轮渲染程序
- 构造MVP矩阵
- 构造ShadowMVP2矩阵 —— 着色器用它查找阴影纹理中的像素坐标
- 将变换矩阵发送到着色器中
- 启用顶点、法向量、纹理坐标的缓冲区
- 调用glDrawArrays（）
除了渲染任务外，顶点和片段着色器还需要额外承担一些任务。
- 顶点着色器：将相机空间转换为光照空间（使用shadowMVP2）（变换为纹理贴图的0，-1），发给片段着色器
- 片元着色器：调用textureProj（）函数，返回0或1，指示像素是否处于阴影中。如果像素处于阴影中，则着色器通过剔除其漫反射和镜面反射分量来输出更暗的像素。
![[8.8自动深度比较 1.png]]

#### 深度比较细节
将顶点转换到阴影纹理坐标，这些坐标对应于投影到光照空间中的顶点坐标。
在片段着色器中使用 sampler2DShadow 和 textureProj()，所渲染的结果将完全满足我们的需求，即 textureProj()将输出 0.0 或 1.0，具体取决于深度比较的结果。

## 阴影贴图示例
还待仔细阅读
源码
```
```
## 阴影贴图的伪影

**阴影痤疮**：即有许多线条覆盖在场景中的表面。这是阴影贴图的常见“副作用”，称为阴影痤疮（shadow acne，也称为阴影斑块）或错误的自阴影。
阴影痤疮是由深度测试期间的舍入误差引起的。在阴影纹理中查找深度信息时计算的纹理坐标通常与实际坐标不完全匹配。
修复：在 display()函数中调用 glPolygonOffset()即可
```cpp
glEnable(GL_POLYGON_OFFSET_FILL);
glPolygonOffset(2.0f,4.0f);
```

**Peter Panning**：静止物体的阴影与物体底部分离
原因：在第 1轮之前移动对象的“技巧”有时会导致在对象阴影中出现间隙。
修复：修复此伪影需要调整glPolygonOffset()的参数。如果参数太小，就会出现阴影痤疮；如果参数太大，则会出现 Peter Panning。

**重复阴影**：
原因：在第 1 轮（存入阴影缓冲区时）渲染的场景区域与第 2 轮渲染的场景区域存在差异（来自不同的观察位置）。
修复：可能的解决方法是将以下代码行添加到 setupShadowBuffers()，将纹理换行模式设置为“夹紧到边缘”：

**锯齿状阴影边缘**：
原因：当投射的阴影明显大于阴影缓冲区可以准确表示的阴影时，就有可能出现此问题。
修复：一种方法是在第 1 轮期间将光源位置移动到更接近场景的位置，然后在第 2 轮将其放回原始位置。另一种常用的有效方法则是下面讨论的“柔和阴影”方法之一。
## 柔和阴影

现实世界中出现的大多数阴影都是柔和阴影，它们的边缘都会发生不同程度的模糊。
我们将探讨现实世界中柔和阴影的外观，然后描述在 OpenGL 中模拟它们的常用算法。消除锯齿状阴影边缘并不像处理之前的伪影那么简单。
### 现实世界中的柔和阴影
真实世界的光源很少是点光源——它们常常是区域光源。

### 生成柔和阴影——百分比邻近滤波（PCF）
我们对单个点周围的几个位置的阴影纹理进行采样，以估计附近位置在阴影中的百分比，并根据附近位置在阴影中的百分比，对正在渲染的像素的光照分量进行修改。整个计算可以在片段着色器中完成，所以我们只需要对片段着色器中的代码进行修改。PCF 还可用于减少锯齿线伪影。
在 PCF 的实现中，不对被渲染像素邻域内的每个像素进行采样。
我们不试图访问附近的像素，而是在阴影贴图中对附近的纹元进行采样。片段着色器可以执行此操作，因为它虽然无法访问附近像素，但可以访问整个阴影贴图。

一种用于实现 PCF 的常见算法是对每个像素附近的 4 个纹元进行采样，其中样本通过像素对应纹元的特定偏移量选择。

### 柔和阴影/PCF 程序
在片元着色器中通过特殊的采用处理方法，生成柔和阴影

## 补充说明
在阴影贴图的每个阶段都使用了透视投影，但值得注意的是，只有当光源是远距离光源和定向光源而非我们使用的位置光时，正射投影通常才是首选。

## 习题
### 不同设置的glPolygonOffset()
glPolygonOffset()的作用：用于解决深度冲突（Z-fighting）问题的函数。它通过调整多边形片段的深度值来避免两个表面在渲染时因深度值过于接近而出现闪烁或视觉错误。

我调整了这个函数，但是无法观察到阴影问题的出现

### 鼠标移动灯光，观察阴影
```cpp
float mouseX, mouseY;

void mouse_callback(GLFWwindow* window, double xpos, double ypos) {
	// 获取窗口大小
	int width, height;
	glfwGetWindowSize(window, &width, &height);

	// 将鼠标坐标归一化到 [-1, 1] 范围
	mouseX = static_cast<float>(xpos) / width * 2.0f - 1.0f;
	mouseY = static_cast<float>(ypos) / height * 2.0f - 1.0f;

	// 更新灯光位置（假设灯光在 XZ 平面上移动）
	lightLoc.x = mouseX * 10.0f; // 缩放因子，根据需要调整
	lightLoc.z = mouseY * 10.0f;
}

//main()
    // 设置鼠标回调函数
    glfwSetCursorPosCallback(window, mouse_callback);
q
```
`static_cast<float>` 是 C++ 中的一种类型转换操作，用于将一个值显式地转换为 `float` 类型。
### 添加动画，添加地平面
如何添加地面

### 修改lookup函数


## 疑惑

1. 阴影纹理是具体到某一个物体对象身上的，但是阴影缓冲区的深度信息是一张从光源方向发出的图，OpenGL是如何将阴影缓冲区的信息识别并复制到阴影纹理中的？简单来说就是，为什么可以从阴影纹理中查找到对应的深度信息。
	1. 需要理解矩阵变换，真实摄像机的每一个顶点都可以被映射到纹理空间下的一个位置，与其进行比较。
2. 为什么要阴影纹理来存储阴影缓冲区里的数据，而不是直接将缓冲区的数据发给着色器？
	1. 使用纹理对象，就可以利用片段着色器中纹理单元和采样器变量（即“纹理贴图”）的硬件支持功能，在第 2 轮快速执行深度查找。
3. 阴影的渲染实现，我可以理解为说是提取物体的信息，生成一份阴影信息，在添加到物体的渲染之上结合，物体就有了影子？
	1. 不应该这样理解，提取到的光源处深度信息，会传达到第二次渲染中，以此渲染出阴影
4. 为什么OpenGL 相机使用[−1,+1]坐标空间？
	1. **相机使用 [−1,+1]坐标空间的原因**
		1. OpenGL 的相机空间最终会将顶点变换到 **标准化设备坐标（NDC）** 空间，范围是 [−1,+1][−1,+1]
		2. **对称性和通用性**：这种对称性使得坐标系统更加通用，适合处理各种视角和投影变换。
		3. **与投影矩阵的兼容性**：透视投影矩阵会将视锥体内的顶点映射到 [−1,+1]3[−1,+1]3 的立方体空间，方便后续的裁剪和视口变换。
		4. **裁剪的简化**
		5. **视口变换的灵活性**
	2. **纹理使用 [0,1]坐标空间的原因**
		1. **归一化和通用性**： 这种归一化的设计使得纹理坐标与纹理的实际分辨率无关，可以适应任意大小的纹理。
		2. **纹理重复和寻址模式**
		3.  **硬件优化**
		4. **与 UV 坐标的兼容性**
5. 光照空间是什么空间？
	1. **光照空间**：从光源视角定义的坐标系，用于统一计算深度
6. 着色器中并没有阴影纹理的变量，只有阴影采样器的变量，那么阴影纹理信息是怎么传递给着色器的？
	1. 纹理信息在被正确读取后，是通过绑定到的纹理单元，然后采样器也绑定到对应的纹理单元。着色器通过绑定到对应纹理单元的采样器，进行读取纹理信息的。
7. textureProj（）函数是如何选择返回1还是0的？就是说如何进行对应纹理与片元深度的对比？
	1. 由于`shadowTex`是`sampler2DShadow`类型，OpenGL会自动进行深度比较。当你调用`texture(shadowTex, shadow_coord.xy)`时，GPU会比较`shadow_coord.z`（当前片段的深度）与阴影纹理中存储的深度值，返回一个比例值（如0或1），表示当前片段是否在阴影中。
## 其他
我对投影矩阵的理解不够透彻，需要自己推导一下 #TODO

**贴图**的本质是一种**数据存储和访问的方式**，而不仅仅是外部图片。阴影贴图（Shadow Map）就是一个很好的例子，它是在渲染过程中动态生成的，而不是从外部加载的。

纹理的绑定相关API
```cpp
// init
glActiveTexture(GL_TEXTURE0);  // 激活纹理单元0
glBindTexture(GL_TEXTURE_2D, shadowTextureID);  // 将阴影纹理绑定到当前纹理单元

//vertex shader
layout (binding=0) uniform sampler2DShadow shadowTex;

float shadow = texture(shadowTex, shadow_coord.xy);
```