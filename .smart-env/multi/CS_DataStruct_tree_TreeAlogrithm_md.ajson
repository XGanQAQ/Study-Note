
"smart_sources:CS/DataStruct/tree/TreeAlogrithm.md": {"path":"CS/DataStruct/tree/TreeAlogrithm.md","last_embed":{"hash":null},"embeddings":{},"last_read":{"hash":"a35edec06f7579c9a83aa1a52d3a4818c71adce29918238232827a0a7df9f569","at":1747299379903},"class_name":"SmartSource","last_import":{"mtime":1731291681928,"size":4351,"at":1747299379904,"hash":"a35edec06f7579c9a83aa1a52d3a4818c71adce29918238232827a0a7df9f569"},"blocks":{"#树的算法":[1,66],"#树的算法##哈夫曼树/最优二叉树":[2,39],"#树的算法##哈夫曼树/最优二叉树#什么是最优二叉树":[4,6],"#树的算法##哈夫曼树/最优二叉树#什么是最优二叉树#{1}":[5,6],"#树的算法##哈夫曼树/最优二叉树#它用于解决什么问题":[7,9],"#树的算法##哈夫曼树/最优二叉树#它用于解决什么问题#{1}":[8,9],"#树的算法##哈夫曼树/最优二叉树#如何构造哈夫曼树/最优二叉树":[10,18],"#树的算法##哈夫曼树/最优二叉树#如何构造哈夫曼树/最优二叉树#{1}":[11,18],"#树的算法##哈夫曼树/最优二叉树#哈夫曼编码":[19,39],"#树的算法##哈夫曼树/最优二叉树#哈夫曼编码#{1}":[20,39],"#---frontmatter---":[22,38],"#树的算法##树的计数":[40,58],"#树的算法##树的计数#n个结点的不同形态的树有多少棵":[42,48],"#树的算法##树的计数#n个结点的不同形态的树有多少棵#{1}":[43,48],"#树的算法##树的计数#已知树的遍历结果顺序，如何反向构造出一棵树":[49,58],"#树的算法##树的计数#已知树的遍历结果顺序，如何反向构造出一棵树#{1}":[50,58],"#树的算法##树的应用":[59,66],"#树的算法##树的应用#{1}":[60,65],"#树的算法##树的应用#{2}":[66,66]},"outlinks":[]},