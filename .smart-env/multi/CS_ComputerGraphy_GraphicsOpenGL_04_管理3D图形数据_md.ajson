
"smart_sources:CS/ComputerGraphy/GraphicsOpenGL/04.管理3D图形数据.md": {"path":"CS/ComputerGraphy/GraphicsOpenGL/04.管理3D图形数据.md","last_embed":{"hash":null},"embeddings":{},"last_read":{"hash":"1a1d5115562807adbd77793acfc64767c961c1df3ceb9e49bd48eacaecbecea4","at":1747299379840},"class_name":"SmartSource","last_import":{"mtime":1738826755745,"size":13860,"at":1747299379841,"hash":"1a1d5115562807adbd77793acfc64767c961c1df3ceb9e49bd48eacaecbecea4"},"blocks":{"##缓冲区和顶点属性":[2,45],"##缓冲区和顶点属性#{1}":[3,5],"##缓冲区和顶点属性#创建VAO和VBO":[6,19],"##缓冲区和顶点属性#创建VAO和VBO#{1}":[7,19],"##缓冲区和顶点属性#顶点着色器声明相应顶点属性变量":[20,27],"##缓冲区和顶点属性#顶点着色器声明相应顶点属性变量#{1}":[21,27],"##缓冲区和顶点属性#读取顶点数据":[28,45],"##缓冲区和顶点属性#读取顶点数据#{1}":[30,45],"##统一变量":[46,66],"##统一变量#{1}":[47,66],"##顶点属性插值":[67,76],"##顶点属性插值#{1}":[68,76],"##MV矩阵和透视矩阵":[77,92],"##MV矩阵和透视矩阵#{1}":[79,79],"##MV矩阵和透视矩阵#{2}":[80,80],"##MV矩阵和透视矩阵#{3}":[81,82],"##MV矩阵和透视矩阵#分析":[83,92],"##MV矩阵和透视矩阵#分析#{1}":[84,85],"##MV矩阵和透视矩阵#分析#{2}":[86,86],"##MV矩阵和透视矩阵#分析#{3}":[87,87],"##MV矩阵和透视矩阵#分析#{4}":[88,89],"##MV矩阵和透视矩阵#分析#{5}":[90,92],"##3D立方体":[93,95],"##3D立方体#{1}":[94,95],"##渲染一个对象的多个副本":[96,112],"##渲染一个对象的多个副本#方法一：直接使用循环创建多个对象":[98,100],"##渲染一个对象的多个副本#方法一：直接使用循环创建多个对象#{1}":[99,100],"##渲染一个对象的多个副本#方法二：实例化":[101,112],"##渲染一个对象的多个副本#方法二：实例化#{1}":[102,112],"##同一个场景中渲染多个不同模型":[113,118],"##同一个场景中渲染多个不同模型#{1}":[115,118],"##矩阵栈":[119,126],"##矩阵栈#{1}":[120,126],"##应对”Z冲突“伪影":[127,136],"##应对”Z冲突“伪影#{1}":[129,136],"##图元的其他选项":[137,140],"##图元的其他选项#{1}":[138,140],"##性能优先的编程方法":[141,159],"##性能优先的编程方法#减少动态内存空间的分配":[143,150],"##性能优先的编程方法#减少动态内存空间的分配#{1}":[144,144],"##性能优先的编程方法#减少动态内存空间的分配#{2}":[145,145],"##性能优先的编程方法#减少动态内存空间的分配#{3}":[146,147],"##性能优先的编程方法#减少动态内存空间的分配#{4}":[148,150],"##性能优先的编程方法#预先计算透视矩阵":[151,153],"##性能优先的编程方法#预先计算透视矩阵#{1}":[152,153],"##性能优先的编程方法#背面剔除":[154,159],"##性能优先的编程方法#背面剔除#{1}":[155,159],"##习题":[160,348],"##习题#4.1自定义3D形状":[162,206],"##习题#4.1自定义3D形状#{1}":[163,206],"##习题#4.2更换相机视图矩阵的实现，更多方向观察":[207,263],"##习题#4.2更换相机视图矩阵的实现，更多方向观察#理论准备":[209,234],"##习题#4.2更换相机视图矩阵的实现，更多方向观察#理论准备#{1}":[210,234],"##习题#4.2更换相机视图矩阵的实现，更多方向观察#实践代码":[235,263],"##习题#4.2更换相机视图矩阵的实现，更多方向观察#实践代码#{1}":[236,263],"##习题#4.3 第二颗行星":[264,326],"##习题#4.3 第二颗行星#{1}":[266,326],"##习题#4.4 不同的查看":[327,340],"##习题#4.4 不同的查看#{1}":[329,340],"##习题#4.5 研究glCullFace(GL_FRONT_AND_BACK)的实际用途":[341,348],"##习题#4.5 研究glCullFace(GL_FRONT_AND_BACK)的实际用途#{1}":[342,342],"##习题#4.5 研究glCullFace(GL_FRONT_AND_BACK)的实际用途#{2}":[343,343],"##习题#4.5 研究glCullFace(GL_FRONT_AND_BACK)的实际用途#{3}":[344,344],"##习题#4.5 研究glCullFace(GL_FRONT_AND_BACK)的实际用途#{4}":[345,345],"##习题#4.5 研究glCullFace(GL_FRONT_AND_BACK)的实际用途#{5}":[346,347],"##习题#4.5 研究glCullFace(GL_FRONT_AND_BACK)的实际用途#{6}":[348,348],"##疑惑点":[349,356],"##疑惑点#{1}":[350,351],"##疑惑点#{2}":[352,352],"##疑惑点#{3}":[353,354],"##疑惑点#{4}":[355,356]},"outlinks":[{"title":"图元类型清单.png","target":"图元类型清单.png","line":139},{"title":"推导视图变换矩阵.png","target":"推导视图变换矩阵.png","line":210}]},