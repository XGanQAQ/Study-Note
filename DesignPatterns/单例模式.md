# 单例模式

## 什么是单例模式

单例模式（Singleton Pattern）是一种创建型设计模式，用于**确保一个类只有一个实例，并提供一个全局访问点来获取该实例**。它在某些情况下很有用，比如管理配置文件、日志系统、数据库连接等，这些场景下需要确保全局的唯一性。

### 关键特点
- 确保一个类只有一个实例
- 提供一个全局访问点来获取该实例

## 单例模式的最简单实现模型

单例模式的最简单实现通常包括以下几个步骤：

1. **私有化构造函数**：防止外部通过 `new` 关键字创建实例。
2. **静态私有变量**：创建一个存储唯一实例的静态变量。
3. **公共静态方法**：提供一个静态方法，用于返回该实例。

以下是一个典型的 C# 实现：

```csharp
public class Singleton
{
    // 静态变量存储唯一实例
    private static Singleton instance;

    // 私有构造函数，防止外部实例化
    private Singleton() { }

    // 公共静态方法获取唯一实例
    public static Singleton GetInstance()
    {
        if (instance == null)
        {
            instance = new Singleton();
        }
        return instance;
    }
}
```

在此模型中，第一次调用 `GetInstance()` 时创建了实例，以后调用返回同一实例。

## 为什么要用单例模式

### 一句话概括——方便在程序的各个地方调用实例
### 具体原因
使用单例模式有以下几个原因：

1. **控制实例数量**：在某些情况下，我们只需要一个对象，比如日志系统、配置管理器等。单例模式确保全局只有一个实例。
2. **减少资源开销**：如果某个类的创建代价很高，单例模式可以避免多次创建，节省系统资源。
3. **全局访问点**：单例模式提供了一个全局访问点，使代码更加结构化和可读。

## 单例模式的问题

### 工程问题

#### 它是一个全局变量
- 会导致代码晦涩难懂
- 促进了耦合
- 对并发不友好

### 理论问题
单例模式的缺点和问题包括：

1. **线程安全问题**：在多线程环境下，可能出现多个线程同时调用 `GetInstance()` 方法导致创建多个实例的情况。
2. **单一职责原则的违背**：单例模式将实例控制的责任和逻辑功能耦合在一起，可能会导致类的复杂度增加。
3. **不易测试**：由于单例模式的全局性和单一实例特性，测试过程中难以模拟不同的状态或在多个测试用例中重置状态。
4. **可能的内存泄漏**：单例对象一旦被创建，通常在整个应用程序生命周期内都不会被销毁，容易造成资源不能及时释放。

## 单例模式的替代方案

### 判断你是否真的需要单例

### 实现单一实例，但不提供全局访问

### 其他便捷的访问实例的方式
- 直接传递，将需要的对象，通过参数传递给函数的方式来访问实例
- 在基类中获取，有一个共同的基类，调用基类的对象，来访问实例
- 通过其他全局对象访问它，用一个全局对象来管控所有其他的单例/全局对象


## 如何改进单例
可以通过以下方法来改进单例模式：

1. **线程安全的单例**：在 `GetInstance()` 方法上加锁，确保在多线程环境中只有一个线程可以创建实例。可以使用双重检查锁定或静态初始化的方式。
   
   例如，双重检查锁定的实现方式：
   ```csharp
   public class Singleton
   {
       private static Singleton instance;
       private static readonly object lockObj = new object();

       private Singleton() { }

       public static Singleton GetInstance()
       {
           if (instance == null)
           {
               lock (lockObj)
               {
                   if (instance == null)
                   {
                       instance = new Singleton();
                   }
               }
           }
           return instance;
       }
   }
   ```

2. **懒汉式和饿汉式**：懒汉式是延迟加载的单例实例，在首次调用 `GetInstance()` 时才创建实例。饿汉式则在类加载时就创建实例，可以通过静态字段初始化实现，适合对性能要求较高且实例化简单的情况。

3. **使用静态构造方法**：C# 中的静态构造方法天然是线程安全的，不需要额外加锁。
   
   ```csharp
   public class Singleton
   {
       private static readonly Singleton instance = new Singleton();

       private Singleton() { }

       public static Singleton Instance => instance;
   }
   ```

4. **依赖注入**：通过依赖注入框架管理单例对象，在需要单例的地方注入它，控制对象生命周期的同时也方便了测试。