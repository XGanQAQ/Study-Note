# 子类沙盒
一个基类定义了一个抽象的沙盒方法和一些预定义的操作集合。设为受保护状态确保它们仅供子类使用。每个派生出的沙盒子类根据父类提供的操作来实现沙盒函数  

简单来说，就是在基类封装好很多方法，然后再在子类中，去组合这些方法。

## 适用情景
假如说你有一个基类，里面有很多方法，然后你有很多子类，这些子类都需要用到这些方法，但是每个子类用到的方法不一样，那么就可以使用子类沙盒模式。

### 实际例子
你想实现魔法系统，有很多种魔法，每种魔法都有自己的实现，但是每种魔法都需要用到一些基本的方法，比如说释放魔法，消耗魔法，这些方法都是一样的，那么就可以使用子类沙盒模式。

## 代码示例
```cpp
class BaseSandbox {
protected:
    void operation1() {
        // Perform operation 1
    }

    void operation2() {
        // Perform operation 2
    }

    // Add more protected operations as needed
};

class DerivedSandbox : public BaseSandbox {
public:
    void sandboxFunction() {
        operation1();
        operation2();
        // Call other operations from the base class
    }
};

int main() {
    DerivedSandbox sandbox;
    sandbox.sandboxFunction();
    return 0;
}

```

## 问题
通过将耦合转交给基类的方法，让子类仅与基类耦合。  
如果随着需要添加的方法变多，基类将变得越来越庞大。

### 需要提供什么操作
- 如果操作仅仅只被少数子类使用，那么不必将其放在基类中。
- 如果调用的方法并不改变状态，那么这个耦合是“安全”的。如果改变了状态，则要考虑由基类去提供。

### 用辅助类再次封装方法
用辅助类对同类型的方法进行二次封装，然后在基类中提供这个辅助类的实例。这样可以减少基类的方法数量。

### 基类获得其所需状态的方法
如果基类需要访问外部实例，并且希望保持对子类隐藏（比如例子系统），有哪些方法可以传递这些实例呢？
1. 构造函数传递  
通过构造函数在子类构造的时候传递实例  
缺点：子类必须知道这个实例是什么，这样就会暴露实例的细节

2. 构造初始化方法传递
使用一个初始化方法来传递实例  
缺点：子类必须调用这个初始化方法  

3. 状态静态化
把需要的实例变成静态变量，这样就可以在基类中直接访问
缺点：缺点就是它是静态的，只有一个实例，不适用于多个实例的情况
4. 服务定位器
使用一个服务定位器来传递实例
缺点：服务定位器是全局的，可能会导致全局状态的问题，并且比较复杂

## 总结
子类沙盒是一种将操作封装在基类中，然后在子类中组合这些操作的方法。这样可以减少子类的耦合，但是也会导致基类变得庞大。可以通过辅助类再次封装方法，或者通过构造函数传递、构造初始化方法传递、状态静态化、服务定位器等方法来传递实例。