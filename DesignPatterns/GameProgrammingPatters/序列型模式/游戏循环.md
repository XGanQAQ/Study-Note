# 游戏循环

## 什么是游戏循环
游戏循环是游戏引擎的核心，它是一个无限循环，游戏在这个循环中不断的更新游戏状态，处理输入，渲染画面，直到游戏结束。  
游戏中存在许多不断更新持续的状态，比如玩家的位置，敌人的位置，子弹的位置等等，游戏循环就是用来更新这些状态的。  

游戏循环的基本结构如下（未包含对时间控制）：
```c++
while (true) {
    // 处理输入
    processInput();
    // 更新游戏状态
    update();
    // 渲染画面
    render();
}
```

## 如何解决不同机器上循环更新速度不同的问题
不同机器的性能不同，导致游戏循环的更新速度不同，这会导致游戏在不同机器上表现不一致。  

### 非同步的固定时间
```cpp
//非同步的固定时间代码示例


```

### 同步的固定时间
固定步长的方法是让游戏循环的每次更新都是固定的（多次调用以追赶实际帧时间），这样就可以解决不同机器上循环更新速度不同的问题。  
适合：处理物理计算，如刚体运动、碰撞检测等。
原理：基于实际流逝时间的差量，使用一个内部循环来更新游戏，直到追赶上时间时间为止
优势：简单，省电。
劣势：在游戏逻辑和渲染花了很多时间的时候，游戏会很慢。游戏帧数有上限，不会很快。
```cpp
//同步的固定时间代码示例
void Game::run() {
    while (true) {
        // 计算上一帧的时间
        float deltaTime = calculateDeltaTime();
        // 更新游戏状态
        while (deltaTime >= m_fixedTimeStep) {
            update(m_fixedTimeStep);
            deltaTime -= m_fixedTimeStep;
        }
        // 渲染画面
        render();
    }
}

```

### 变时步长
变时步长的方法是让游戏循环的时间和世界的时间保持一致，这样就可以解决不同机器上循环更新速度不同的问题。  
适合：处理用户输入、非物理相关逻辑、UI 更新等。
原理：计算出每帧之间的时间差，然后传入update方法，update方法通过这个参数来控制变化的幅度。
优势：可以适应多种硬件平台。可以很快
劣势：物理模拟和网络模块变得不稳定不确定
```cpp
//变时步长代码示例
void Game::run() {
    while (true) {
        // 计算上一帧的时间
        float deltaTime = calculateDeltaTime();
        // 更新游戏状态
        update(deltaTime);
        // 渲染画面
        render();
    }
}

```

### 定时更新迭代，变时渲染
定时更新迭代，变时渲染的方法是让游戏循环的更新和渲染分开，更新是固定的，渲染是变时的，这样就可以解决不同机器上循环更新速度不同的问题。

## 什么是游戏帧
一个游戏帧代表的是游戏循环更新一次，它包含了游戏在一次循环中的所有内容（处理输入，游戏逻辑，渲染等），游戏帧率是指每秒更新的次数，一般游戏帧率是60帧每秒，也就是每秒更新60次。